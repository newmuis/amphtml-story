import {dev} from '../../../src/log';
import {Services} from '../../../src/services';

/**
 * Copyright 2017 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/** @typedef {{ source: AudioBufferSourceNode, gainNode: GainNode }} */
let AudioSource;

/** @const {!AudioContext} */
const context = new (window.AudioContext || window.webkitAudioContext)();

/**
 * The volume to which audio should be reduced when other audio sources are
 * played.
 * @const {number}
 */
const REDUCED_VOLUME = 0.3;

/**
 * @const {number}
 */
const VOLUME_CHANGE_DURATION_MS = 500;

/**
 * @const {!function(number): number}
 */
const VOLUME_EASING_FN = input => input;

/**
 * @const {string}
 */
const PLAYABLE_ID_PREFIX = 'i-amphtml-playable-';


export class AudioManager {
  constructor() {
    /** @const {!Object<!Element, !Playable>} */
    this.playables_ = {};

    /** @const {!Array<number>} */
    this.nowPlaying_ = [];

    /** @type {number} */
    this.nextId_ = 0;
  }

  /**
   * @param {!Element} sourceElement The element causing audio to be played.
   * @return {!Playable} The {@link Playable} instance to play the audio
   *     represented by the specified sourceElement.
   */
  createPlayable_(sourceElement) {
    if (!(sourceElement instanceof Element)) {
      dev().error('amp-story', 'Played item must be element.');
    }

    if (sourceElement instanceof HTMLMediaElement) {
      return new MediaElementPlayable(sourceElement);
    } else if (sourceElement.hasAttribute('background-audio')) {
      if (sourceElement.tagName.toLowerCase() === 'amp-story' ||
          sourceElement.tagName.toLowerCase() === 'amp-story-page') {
        return new BackgroundPlayable(sourceElement);
      }
    }
  }

  /**
   * @param {!Element} sourceElement 
   * @return {?Playable}
   */
  getPlayable_(sourceElement) {
    return this.playables_[sourceElement.id];
  }

  load(sourceElement) {
    const playable = this.getPlayable_(sourceElement) ||
        this.createPlayable_(sourceElement);

    if (!playable) {
      return Promise.resolve();
    }

    if (!sourceElement.id) {
      sourceElement.id = `${PLAYABLE_ID_PREFIX}${this.nextId_++}`;
    }

    this.playables_[sourceElement.id] = playable;
    return playable.load();
  }

  play(sourceElement) {
    this.load(sourceElement).then(() => {
      const playable = this.getPlayable_(sourceElement);
      if (!playable || playable.isPlaying()) {
        return;
      }

      // Stop all siblings.
      for (let el = sourceElement.parentElement.firstElementChild; el;
          el = el.nextElementSibling) {
        if (el === sourceElement) {
          continue;
        }

        this.stop(el);
      }

      // Reduce the volume of ancestors.
      for (let el = sourceElement.parentElement; el;
          el = el.parentElement) {
        this.setVolume(el, REDUCED_VOLUME);
      }

      // Play the audio.
      playable.play();
    });
  }

  /**
   * Stops the audio generated by a given element.
   * @param {!Element} sourceElement 
   */
  stop(sourceElement) {
    const playable = this.getPlayable_(sourceElement);
    if (!playable || !playable.isPlaying()) {
      return;
    }

    playable.stop();
  }

  /**
   * Reduce the volume of the audio generated by a given element.
   * @param {!Element} sourceElement 
   * @param {number} volume 
   */
  setVolume(sourceElement, volume) {
    const playable = this.getPlayable_(sourceElement);
    if (!playable) {
      return;
    }

    playable.setVolume(volume, VOLUME_CHANGE_DURATION_MS, VOLUME_EASING_FN);
  }
}


class Playable {
  constructor(sourceElement) {
    /**
     * The element that is causing audio to be played.
     * @private @const {!Element}
     */
    this.sourceElement_ = sourceElement;
  }

  /**
   * @return {!Element} The element causing audio to be played.
   */
  getSourceElement() {
    return this.sourceElement_;
  }

  /**
   * Loads the resources necessary to play this item.  Should be a no-op if
   * called when the item is already loaded.
   * @return {!Promise} A promise that is resolved once the resource has been
   *     loaded.
   */
  load() {
    return Promise.resolve();
  }

  /**
   * @return {boolean} true, if this item's resources have been loaded.
   */
  isLoaded() {
    return false;
  }

  /**
   * Causes this item to start playing if it was not already playing.  load()
   * will be called before play() in all cases.  play() should be a no-op if the
   * item is already being played.
   */
  play() {}

  /**
   * Sets the volume of this item to the specified volume, over the specified
   * duration of time.
   *
   * @param {number} unusedVolume A volume from 0.0 (silent) to 1.0 (loudest).
   * @param {number} unusedDurationMs The duration over which the new volume
   *     should be achieved.
   * @param {!function(number): number} unusedEasingFn The easing function which
   *     describes the curve the volume should be modified.
   */
  setVolume(unusedVolume, unusedDurationMs, unusedEasingFn) {}

  /**
   * Causes this item to stop playing if it was playing.  stop() should be a
   * no-op if the item is already stopped.
   */
  stop() {}

  /**
   * Unloads the resources associated with this item.  Can be called to free up
   * resources.  Should be a no-op if called when the item is not yet loaded.
   */
  unload() {}
}


/**
 * A playable piece of audio loaded from a URI via XHR and played using the
 * WebAudio APIs.
 */
class BackgroundPlayable extends Playable {
  constructor(sourceElement) {
    super(sourceElement);

    // TODO(newmuis): Assert source URI.
    /** @private @const {string} */
    this.sourceUri_ = sourceElement.getAttribute('background-audio');

    this.buffer_ = null;

    /** @private {?AudioSource} */
    this.audioSource_ = null;
  }

  /**
   * 
   * @param {*} buffer 
   */
  createSource_(buffer) {
    const source = context.createBufferSource();
    const gainNode = context.createGain();

    source.buffer = buffer;
    source.loop = true;
    source.connect(gainNode);
    gainNode.connect(context.destination);

    this.audioSource_ = {
      source,
      gainNode,
    };
  }

  /** @override */
  isLoaded() {
    return !!this.buffer_;
  }

  /** @override */
  isPlaying() {
    return !!this.audioSource_;
  }

  /** @override */
  load() {
    if (this.isLoaded()) {
      return Promise.resolve();
    }

    return Services.xhrFor(window)
        .fetch(this.sourceUri_)
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => this.decodeAudioData_(arrayBuffer))
        .then(buffer => this.buffer_ = buffer);
  }


  /**
   * Transforms an ArrayBuffer into an audio buffer.
   * @param {!ArrayBuffer} arrayBuffer The array buffer containing the bytes of
   *     the audio to be decoded.
   * @return {!Promise<!AudioBuffer>}
   * @private
   */
  decodeAudioData_(arrayBuffer) {
    return new Promise((resolve, reject) => {
      context.decodeAudioData(arrayBuffer,
          audioBuffer => resolve(audioBuffer), error => reject(error));
    });
  }

  /** @override */
  play() {
    this.load()
        .then(() => this.createSource_(this.buffer_))
        .then(() => this.playSource_());
  }

  /**
   * @private
   */
  playSource_() {
    if (this.audioSource_.source.start) {
      this.audioSource_.source.start(0);
    } else {
      this.audioSource_.source.noteOn(0);
    }
  }

  /** @override */
  setVolume(volume, durationMs, easingFn) {
    // TODO(newmuis): Fade to volume over durationMs following easingFn.
    this.audioSource_.gainNode.value = volume;
  }

  /** @override */
  stop() {
    if (this.audioSource_.source.stop) {
      this.audioSource_.source.stop(0);
    } else {
      this.audioSource_.source.noteOff(0);
    }
    this.audioSource_ = null;
  }

  /** @override */
  unload() {
    if (!this.isLoaded) {
      return;
    }
    this.buffer_ = null;
  }
}


/**
 * An HTMLMediaElement that potentially has audio.
 */
class MediaElementPlayable extends Playable {
  constructor(element) {
    super(dev().assert(element instanceof HTMLMediaElement,
        'Only media elements can be played.'));
    this.element_ = element;
  }

  /** @override */
  isLoaded() {
    return !!this.element_;
  }

  /** @override */
  isPlaying() {
    return !this.element_.paused;
  }

  /** @override */
  play() {
    this.element_.play();
  }

  /** @override */
  setVolume(volume, durationMs, easingFn) {
    const startTimeMs = Date.now();

    function stepVolume() {
      this.vsync_.mutate(() => {
        const currentTimeMs = Date.now();
        const elapsedTimeMs = currentTimeMs - startTimeMs;
        const currentPercentage = elapsedTimeMs / durationMs;
        this.element_.volume = easingFn(currentPercentage);

        if (currentPercentage < 1) {
          stepVolume();
        }
      });
    }

    stepVolume();
  }

  /** @override */
  stop() {
    this.element_.pause();
    this.element_.currentTime = 0;
  }
}
